/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const EC_MAX_NUM_DEVICES: u32 = 1;
pub const EC_MAX_SYNC_MANAGERS: u32 = 16;
pub const EC_MAX_STRING_LENGTH: u32 = 64;
pub const EC_MAX_PORTS: u32 = 4;
pub const EC_MAX_SII_SIZE: u32 = 4096;
pub const EC_MAX_FMMUS: u32 = 16;
pub const EC_MAX_HOSTNAME_SIZE: u32 = 32;
pub const EC_IOCTL_TYPE: u32 = 164;
pub const EC_IOCTL_VERSION_MAGIC: u32 = 36;
pub const EC_IOCTL_STRING_SIZE: u32 = 64;
pub const EC_MAX_SDO_DATA_SIZE: u32 = 1024;
pub const EC_MAX_IDN_DATA_SIZE: u32 = 1024;
pub type size_t = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " Master state."]
#[doc = ""]
#[doc = " This is used for the output parameter of ecrt_master_state()."]
#[doc = ""]
#[doc = " \\see ecrt_master_state()."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_master_state_t {
    #[doc = "< Sum of responding slaves on all"]
    #[doc = "Ethernet devices."]
    pub slaves_responding: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ec_master_state_t {
    #[inline]
    pub fn al_states(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_states(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn link_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_busy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_busy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        al_states: ::std::os::raw::c_uint,
        link_up: ::std::os::raw::c_uint,
        scan_busy: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let al_states: u32 = unsafe { ::std::mem::transmute(al_states) };
            al_states as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let link_up: u32 = unsafe { ::std::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_busy: u32 = unsafe { ::std::mem::transmute(scan_busy) };
            scan_busy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Redundant link state."]
#[doc = ""]
#[doc = " This is used for the output parameter of ecrt_master_link_state()."]
#[doc = ""]
#[doc = " \\see ecrt_master_link_state()."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_master_link_state_t {
    #[doc = "< Sum of responding slaves on the given"]
    #[doc = "link."]
    pub slaves_responding: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ec_master_link_state_t {
    #[inline]
    pub fn al_states(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_states(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn link_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        al_states: ::std::os::raw::c_uint,
        link_up: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let al_states: u32 = unsafe { ::std::mem::transmute(al_states) };
            al_states as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let link_up: u32 = unsafe { ::std::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Slave configuration state."]
#[doc = ""]
#[doc = " This is used as an output parameter of ecrt_slave_config_state()."]
#[doc = ""]
#[doc = " \\see ecrt_slave_config_state()."]
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct ec_slave_config_state_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Offset of the slave in the ring."]
    pub position: u16,
}
impl ec_slave_config_state_t {
    #[inline]
    pub fn online(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_online(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn operational(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_operational(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn al_state(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_state(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn error_flag(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_flag(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ready(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ready(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        online: ::std::os::raw::c_uint,
        operational: ::std::os::raw::c_uint,
        al_state: ::std::os::raw::c_uint,
        error_flag: ::std::os::raw::c_uint,
        ready: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let online: u32 = unsafe { ::std::mem::transmute(online) };
            online as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let operational: u32 = unsafe { ::std::mem::transmute(operational) };
            operational as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let al_state: u32 = unsafe { ::std::mem::transmute(al_state) };
            al_state as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let error_flag: u32 = unsafe { ::std::mem::transmute(error_flag) };
            error_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ready: u32 = unsafe { ::std::mem::transmute(ready) };
            ready as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Port is not implemented."]
pub const EC_PORT_NOT_IMPLEMENTED: ec_slave_port_desc_t = 0;
#[doc = "< Port is not configured."]
pub const EC_PORT_NOT_CONFIGURED: ec_slave_port_desc_t = 1;
#[doc = "< Port is an E-Bus."]
pub const EC_PORT_EBUS: ec_slave_port_desc_t = 2;
#[doc = "< Port is a MII."]
pub const EC_PORT_MII: ec_slave_port_desc_t = 3;
#[doc = " EtherCAT slave port descriptor."]
pub type ec_slave_port_desc_t = ::std::os::raw::c_uint;
#[doc = " EtherCAT slave port information."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_slave_port_link_t {
    #[doc = "< Link detected."]
    pub link_up: u8,
    #[doc = "< Loop closed."]
    pub loop_closed: u8,
    #[doc = "< Detected signal on RX port."]
    pub signal_detected: u8,
    #[doc = "< Packets are bypassing this port (eg. redundancy)"]
    pub bypassed: u8,
}
#[doc = "< No registered process data were exchanged."]
pub const EC_WC_ZERO: ec_wc_state_t = 0;
#[doc = "< Some of the registered process data were"]
#[doc = "exchanged."]
pub const EC_WC_INCOMPLETE: ec_wc_state_t = 1;
#[doc = "< All registered process data were exchanged."]
pub const EC_WC_COMPLETE: ec_wc_state_t = 2;
#[doc = " Domain working counter interpretation."]
#[doc = ""]
#[doc = " This is used in ec_domain_state_t."]
pub type ec_wc_state_t = ::std::os::raw::c_uint;
#[doc = " Domain state."]
#[doc = ""]
#[doc = " This is used for the output parameter of ecrt_domain_state()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_domain_state_t {
    #[doc = "< Value of the last working counter."]
    pub working_counter: ::std::os::raw::c_uint,
    #[doc = "< Working counter interpretation."]
    pub wc_state: ec_wc_state_t,
    #[doc = "< Redundant link is in use."]
    pub redundancy_active: ::std::os::raw::c_uint,
}
impl Default for ec_domain_state_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "< Invalid direction. Do not use this value."]
pub const EC_DIR_INVALID: ec_direction_t = 0;
#[doc = "< Values written by the master."]
pub const EC_DIR_OUTPUT: ec_direction_t = 1;
#[doc = "< Values read by the master."]
pub const EC_DIR_INPUT: ec_direction_t = 2;
#[doc = "< Values read and written by the master."]
pub const EC_DIR_BOTH: ec_direction_t = 3;
#[doc = "< Number of directions. For internal use only."]
pub const EC_DIR_COUNT: ec_direction_t = 4;
#[doc = " Direction type for PDO assignment functions."]
pub type ec_direction_t = ::std::os::raw::c_uint;
#[doc = "< Use the default setting of the sync manager."]
pub const EC_WD_DEFAULT: ec_watchdog_mode_t = 0;
#[doc = "< Enable the watchdog."]
pub const EC_WD_ENABLE: ec_watchdog_mode_t = 1;
#[doc = "< Disable the watchdog."]
pub const EC_WD_DISABLE: ec_watchdog_mode_t = 2;
#[doc = " Watchdog mode for sync manager configuration."]
#[doc = ""]
#[doc = " Used to specify, if a sync manager's watchdog is to be enabled."]
pub type ec_watchdog_mode_t = ::std::os::raw::c_uint;
#[doc = "< Not requested."]
pub const EC_REQUEST_UNUSED: ec_request_state_t = 0;
#[doc = "< Request is being processed."]
pub const EC_REQUEST_BUSY: ec_request_state_t = 1;
#[doc = "< Request was processed successfully."]
pub const EC_REQUEST_SUCCESS: ec_request_state_t = 2;
#[doc = "< Request processing failed."]
pub const EC_REQUEST_ERROR: ec_request_state_t = 3;
#[doc = " Request state."]
#[doc = ""]
#[doc = " This is used as return type for ecrt_sdo_request_state() and"]
#[doc = " ecrt_voe_handler_state()."]
pub type ec_request_state_t = ::std::os::raw::c_uint;
#[doc = "< Busy."]
pub const FOE_BUSY: ec_foe_error_t = 0;
#[doc = "< Ready."]
pub const FOE_READY: ec_foe_error_t = 1;
#[doc = "< Idle."]
pub const FOE_IDLE: ec_foe_error_t = 2;
#[doc = "< Working counter error."]
pub const FOE_WC_ERROR: ec_foe_error_t = 3;
#[doc = "< Receive error."]
pub const FOE_RECEIVE_ERROR: ec_foe_error_t = 4;
#[doc = "< Protocol error."]
pub const FOE_PROT_ERROR: ec_foe_error_t = 5;
#[doc = "< No data error."]
pub const FOE_NODATA_ERROR: ec_foe_error_t = 6;
#[doc = "< Packet number error."]
pub const FOE_PACKETNO_ERROR: ec_foe_error_t = 7;
#[doc = "< OpCode error."]
pub const FOE_OPCODE_ERROR: ec_foe_error_t = 8;
#[doc = "< Timeout error."]
pub const FOE_TIMEOUT_ERROR: ec_foe_error_t = 9;
#[doc = "< Error sending received data."]
pub const FOE_SEND_RX_DATA_ERROR: ec_foe_error_t = 10;
#[doc = "< Error acknowledging received data."]
pub const FOE_RX_DATA_ACK_ERROR: ec_foe_error_t = 11;
#[doc = "< Acknowledge error."]
pub const FOE_ACK_ERROR: ec_foe_error_t = 12;
#[doc = "< Error fetching data from mailbox."]
pub const FOE_MBOX_FETCH_ERROR: ec_foe_error_t = 13;
#[doc = "< No data while reading."]
pub const FOE_READ_NODATA_ERROR: ec_foe_error_t = 14;
#[doc = "< Mailbox protocol error."]
pub const FOE_MBOX_PROT_ERROR: ec_foe_error_t = 15;
#[doc = "< Read buffer overflow."]
pub const FOE_READ_OVER_ERROR: ec_foe_error_t = 16;
#[doc = " FoE error enumeration type."]
pub type ec_foe_error_t = ::std::os::raw::c_uint;
#[doc = "< Init."]
pub const EC_AL_STATE_INIT: ec_al_state_t = 1;
#[doc = "< Pre-operational."]
pub const EC_AL_STATE_PREOP: ec_al_state_t = 2;
#[doc = "< Safe-operational."]
pub const EC_AL_STATE_SAFEOP: ec_al_state_t = 4;
#[doc = "< Operational."]
pub const EC_AL_STATE_OP: ec_al_state_t = 8;
#[doc = " Application-layer state."]
pub type ec_al_state_t = ::std::os::raw::c_uint;
#[doc = " Slave information interface CANopen over EtherCAT details flags."]
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ec_sii_coe_details_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl ec_sii_coe_details_t {
    #[inline]
    pub fn enable_sdo(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_sdo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_sdo_info(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_sdo_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_pdo_assign(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_pdo_assign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_pdo_configuration(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_pdo_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_upload_at_startup(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_upload_at_startup(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_sdo_complete_access(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_sdo_complete_access(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_sdo: u8,
        enable_sdo_info: u8,
        enable_pdo_assign: u8,
        enable_pdo_configuration: u8,
        enable_upload_at_startup: u8,
        enable_sdo_complete_access: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_sdo: u8 = unsafe { ::std::mem::transmute(enable_sdo) };
            enable_sdo as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_sdo_info: u8 = unsafe { ::std::mem::transmute(enable_sdo_info) };
            enable_sdo_info as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enable_pdo_assign: u8 = unsafe { ::std::mem::transmute(enable_pdo_assign) };
            enable_pdo_assign as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enable_pdo_configuration: u8 =
                unsafe { ::std::mem::transmute(enable_pdo_configuration) };
            enable_pdo_configuration as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enable_upload_at_startup: u8 =
                unsafe { ::std::mem::transmute(enable_upload_at_startup) };
            enable_upload_at_startup as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enable_sdo_complete_access: u8 =
                unsafe { ::std::mem::transmute(enable_sdo_complete_access) };
            enable_sdo_complete_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Slave information interface general flags."]
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ec_sii_general_flags_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl ec_sii_general_flags_t {
    #[inline]
    pub fn enable_safeop(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_safeop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_not_lrw(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_not_lrw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_safeop: u8,
        enable_not_lrw: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_safeop: u8 = unsafe { ::std::mem::transmute(enable_safeop) };
            enable_safeop as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_not_lrw: u8 = unsafe { ::std::mem::transmute(enable_not_lrw) };
            enable_not_lrw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< 32 bit."]
pub const EC_DC_32: ec_slave_dc_range_t = 0;
pub const EC_DC_64: ec_slave_dc_range_t = 1;
#[doc = " EtherCAT slave distributed clocks range."]
pub type ec_slave_dc_range_t = ::std::os::raw::c_uint;
#[doc = " EtherCAT slave sync signal configuration."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_sync_signal_t {
    #[doc = "< Cycle time [ns]."]
    pub cycle_time: u32,
    #[doc = "< Shift time [ns]."]
    pub shift_time: i32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_module_t {
    pub ioctl_version_magic: u32,
    pub master_count: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_master_t {
    pub slave_count: u32,
    pub config_count: u32,
    pub domain_count: u32,
    pub eoe_handler_count: u32,
    pub phase: u8,
    pub active: u8,
    pub scan_busy: u8,
    pub devices: [ec_ioctl_master_t_ec_ioctl_device; 1usize],
    pub num_devices: u32,
    pub tx_count: u64,
    pub rx_count: u64,
    pub tx_bytes: u64,
    pub rx_bytes: u64,
    pub tx_frame_rates: [i32; 3usize],
    pub rx_frame_rates: [i32; 3usize],
    pub tx_byte_rates: [i32; 3usize],
    pub rx_byte_rates: [i32; 3usize],
    pub loss_rates: [i32; 3usize],
    pub app_time: u64,
    pub dc_ref_time: u64,
    pub ref_clock: u16,
    pub pcap_size: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_master_t_ec_ioctl_device {
    pub address: [u8; 6usize],
    pub attached: u8,
    pub link_state: u8,
    pub tx_count: u64,
    pub rx_count: u64,
    pub tx_bytes: u64,
    pub rx_bytes: u64,
    pub tx_errors: u64,
    pub tx_frame_rates: [i32; 3usize],
    pub rx_frame_rates: [i32; 3usize],
    pub tx_byte_rates: [i32; 3usize],
    pub rx_byte_rates: [i32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_t {
    pub position: u16,
    pub device_index: ::std::os::raw::c_uint,
    pub vendor_id: u32,
    pub product_code: u32,
    pub revision_number: u32,
    pub serial_number: u32,
    pub alias: u16,
    pub boot_rx_mailbox_offset: u16,
    pub boot_rx_mailbox_size: u16,
    pub boot_tx_mailbox_offset: u16,
    pub boot_tx_mailbox_size: u16,
    pub std_rx_mailbox_offset: u16,
    pub std_rx_mailbox_size: u16,
    pub std_tx_mailbox_offset: u16,
    pub std_tx_mailbox_size: u16,
    pub mailbox_protocols: u16,
    pub has_general_category: u8,
    pub coe_details: ec_sii_coe_details_t,
    pub general_flags: ec_sii_general_flags_t,
    pub current_on_ebus: i16,
    pub ports: [ec_ioctl_slave_t__bindgen_ty_1; 4usize],
    pub upstream_port: u8,
    pub fmmu_bit: u8,
    pub dc_supported: u8,
    pub dc_range: ec_slave_dc_range_t,
    pub has_dc_system_time: u8,
    pub transmission_delay: u32,
    pub al_state: u8,
    pub error_flag: u8,
    pub scan_required: u8,
    pub ready: u8,
    pub sync_count: u8,
    pub sdo_count: u16,
    pub sii_nwords: u32,
    pub group: [::std::os::raw::c_char; 64usize],
    pub image: [::std::os::raw::c_char; 64usize],
    pub order: [::std::os::raw::c_char; 64usize],
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_t__bindgen_ty_1 {
    pub desc: ec_slave_port_desc_t,
    pub link: ec_slave_port_link_t,
    pub receive_time: u32,
    pub next_slave: u16,
    pub delay_to_next_dc: u32,
}
impl Default for ec_ioctl_slave_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Default for ec_ioctl_slave_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_slave_sync_t {
    pub slave_position: u16,
    pub sync_index: u32,
    pub physical_start_address: u16,
    pub default_size: u16,
    pub control_register: u8,
    pub enable: u8,
    pub pdo_count: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sync_pdo_t {
    pub slave_position: u16,
    pub sync_index: u32,
    pub pdo_pos: u32,
    pub index: u16,
    pub entry_count: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sync_pdo_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sync_pdo_entry_t {
    pub slave_position: u16,
    pub sync_index: u32,
    pub pdo_pos: u32,
    pub entry_pos: u32,
    pub index: u16,
    pub subindex: u8,
    pub bit_length: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sync_pdo_entry_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_domain_t {
    pub index: u32,
    pub data_size: u32,
    pub logical_base_address: u32,
    pub working_counter: [u16; 1usize],
    pub expected_working_counter: u16,
    pub fmmu_count: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_domain_fmmu_t {
    pub domain_index: u32,
    pub fmmu_index: u32,
    pub slave_config_alias: u16,
    pub slave_config_position: u16,
    pub sync_index: u8,
    pub dir: ec_direction_t,
    pub logical_address: u32,
    pub data_size: u32,
}
impl Default for ec_ioctl_domain_fmmu_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_domain_data_t {
    pub domain_index: u32,
    pub data_size: u32,
    pub target: *mut u8,
}
impl Default for ec_ioctl_domain_data_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_pcap_data_t {
    pub data_size: u32,
    pub reset_data: u8,
    pub target: *mut u8,
}
impl Default for ec_ioctl_pcap_data_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_slave_state_t {
    pub slave_position: u16,
    pub al_state: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_t {
    pub slave_position: u16,
    pub sdo_position: u16,
    pub sdo_index: u16,
    pub max_subindex: u8,
    pub object_code: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sdo_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_entry_t {
    pub slave_position: u16,
    pub sdo_spec: ::std::os::raw::c_int,
    pub sdo_entry_subindex: u8,
    pub data_type: u16,
    pub bit_length: u16,
    pub read_access: [u8; 3usize],
    pub write_access: [u8; 3usize],
    pub description: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sdo_entry_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_upload_t {
    pub slave_position: u16,
    pub sdo_index: u16,
    pub sdo_entry_subindex: u8,
    pub complete_access: u8,
    pub target_size: size_t,
    pub target: *mut u8,
    pub data_size: size_t,
    pub abort_code: u32,
}
impl Default for ec_ioctl_slave_sdo_upload_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_download_t {
    pub slave_position: u16,
    pub sdo_index: u16,
    pub sdo_entry_subindex: u8,
    pub complete_access: u8,
    pub data_size: size_t,
    pub data: *const u8,
    pub abort_code: u32,
}
impl Default for ec_ioctl_slave_sdo_download_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sii_t {
    pub slave_position: u16,
    pub offset: u16,
    pub nwords: u32,
    pub words: *mut u16,
}
impl Default for ec_ioctl_slave_sii_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_reg_t {
    pub slave_position: u16,
    pub emergency: u8,
    pub address: u16,
    pub size: size_t,
    pub data: *mut u8,
}
impl Default for ec_ioctl_slave_reg_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_slave_reboot_t {
    pub slave_position: u16,
    pub broadcast: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_foe_t {
    pub password: u32,
    pub slave_position: u16,
    pub offset: u16,
    pub buffer_size: size_t,
    pub buffer: *mut u8,
    pub data_size: size_t,
    pub result: u32,
    pub error_code: u32,
    pub file_name: [::std::os::raw::c_char; 255usize],
}
impl Default for ec_ioctl_slave_foe_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_soe_read_t {
    pub slave_position: u16,
    pub drive_no: u8,
    pub idn: u16,
    pub mem_size: size_t,
    pub data: *mut u8,
    pub data_size: size_t,
    pub error_code: u16,
}
impl Default for ec_ioctl_slave_soe_read_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_soe_write_t {
    pub slave_position: u16,
    pub drive_no: u8,
    pub idn: u16,
    pub data_size: size_t,
    pub data: *mut u8,
    pub error_code: u16,
}
impl Default for ec_ioctl_slave_soe_write_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_t {
    pub config_index: u32,
    pub alias: u16,
    pub position: u16,
    pub vendor_id: u32,
    pub product_code: u32,
    pub syncs: [ec_ioctl_config_t__bindgen_ty_1; 16usize],
    pub watchdog_divider: u16,
    pub watchdog_intervals: u16,
    pub sdo_count: u32,
    pub idn_count: u32,
    pub slave_position: i32,
    pub dc_assign_activate: u16,
    pub dc_sync: [ec_sync_signal_t; 2usize],
    pub allow_overlapping_pdos: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_t__bindgen_ty_1 {
    pub dir: ec_direction_t,
    pub watchdog_mode: ec_watchdog_mode_t,
    pub pdo_count: u32,
    pub config_this: u8,
}
impl Default for ec_ioctl_config_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Default for ec_ioctl_config_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_pdo_t {
    pub config_index: u32,
    pub sync_index: u8,
    pub pdo_pos: u16,
    pub index: u16,
    pub entry_count: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_config_pdo_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_pdo_entry_t {
    pub config_index: u32,
    pub sync_index: u8,
    pub pdo_pos: u16,
    pub entry_pos: u8,
    pub index: u16,
    pub subindex: u8,
    pub bit_length: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_config_pdo_entry_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_sdo_t {
    pub config_index: u32,
    pub sdo_pos: u32,
    pub index: u16,
    pub subindex: u8,
    pub size: size_t,
    pub data: [u8; 1024usize],
    pub complete_access: u8,
}
impl Default for ec_ioctl_config_sdo_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_idn_t {
    pub config_index: u32,
    pub idn_pos: u32,
    pub drive_no: u8,
    pub idn: u16,
    pub state: ec_al_state_t,
    pub size: size_t,
    pub data: [u8; 1024usize],
}
impl Default for ec_ioctl_config_idn_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_eoe_handler_t {
    pub eoe_index: u16,
    pub name: [::std::os::raw::c_char; 20usize],
    pub slave_position: u16,
    pub open: u8,
    pub rx_bytes: u32,
    pub rx_rate: u32,
    pub tx_bytes: u32,
    pub tx_rate: u32,
    pub tx_queued_frames: u32,
    pub tx_queue_size: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_eoe_if_t {
    pub alias: u16,
    pub position: u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_slave_eoe_ip_t {
    pub slave_position: u16,
    pub mac_address_included: u8,
    pub ip_address_included: u8,
    pub subnet_mask_included: u8,
    pub gateway_included: u8,
    pub dns_included: u8,
    pub name_included: u8,
    pub mac_address: [::std::os::raw::c_uchar; 6usize],
    pub ip_address: u32,
    pub subnet_mask: u32,
    pub gateway: u32,
    pub dns: u32,
    pub name: [::std::os::raw::c_char; 32usize],
    pub result: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_master_activate_t {
    pub process_data: *mut ::std::os::raw::c_void,
    pub process_data_size: size_t,
}
impl Default for ec_ioctl_master_activate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_add_pdo_entry_t {
    pub config_index: u32,
    pub pdo_index: u16,
    pub entry_index: u16,
    pub entry_subindex: u8,
    pub entry_bit_length: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_reg_pdo_entry_t {
    pub config_index: u32,
    pub entry_index: u16,
    pub entry_subindex: u8,
    pub domain_index: u32,
    pub bit_position: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_reg_pdo_pos_t {
    pub config_index: u32,
    pub sync_index: u32,
    pub pdo_pos: u32,
    pub entry_pos: u32,
    pub domain_index: u32,
    pub bit_position: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_sdo_t {
    pub config_index: u32,
    pub index: u16,
    pub subindex: u8,
    pub data: *const u8,
    pub size: size_t,
    pub complete_access: u8,
}
impl Default for ec_ioctl_sc_sdo_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_emerg_t {
    pub config_index: u32,
    pub size: size_t,
    pub target: *mut u8,
    pub overruns: i32,
}
impl Default for ec_ioctl_sc_emerg_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_state_t {
    pub config_index: u32,
    pub state: *mut ec_slave_config_state_t,
}
impl Default for ec_ioctl_sc_state_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_idn_t {
    pub config_index: u32,
    pub drive_no: u8,
    pub idn: u16,
    pub al_state: ec_al_state_t,
    pub data: *const u8,
    pub size: size_t,
}
impl Default for ec_ioctl_sc_idn_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_domain_state_t {
    pub domain_index: u32,
    pub state: *mut ec_domain_state_t,
}
impl Default for ec_ioctl_domain_state_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sdo_request_t {
    pub config_index: u32,
    pub request_index: u32,
    pub sdo_index: u16,
    pub sdo_subindex: u8,
    pub complete_access: u8,
    pub size: size_t,
    pub data: *mut u8,
    pub timeout: u32,
    pub state: ec_request_state_t,
}
impl Default for ec_ioctl_sdo_request_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_foe_request_t {
    pub config_index: u32,
    pub request_index: u32,
    pub password: u32,
    pub size: size_t,
    pub progress: size_t,
    pub data: *mut u8,
    pub timeout: u32,
    pub state: ec_request_state_t,
    pub result: ec_foe_error_t,
    pub error_code: u32,
    pub file_name: [::std::os::raw::c_char; 255usize],
}
impl Default for ec_ioctl_foe_request_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_reg_request_t {
    pub config_index: u32,
    pub mem_size: size_t,
    pub request_index: u32,
    pub data: *mut u8,
    pub state: ec_request_state_t,
    pub new_data: u8,
    pub address: u16,
    pub transfer_size: size_t,
}
impl Default for ec_ioctl_reg_request_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_voe_t {
    pub config_index: u32,
    pub voe_index: u32,
    pub vendor_id: *mut u32,
    pub vendor_type: *mut u16,
    pub size: size_t,
    pub data: *mut u8,
    pub state: ec_request_state_t,
}
impl Default for ec_ioctl_voe_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_link_state_t {
    pub dev_idx: u32,
    pub state: *mut ec_master_link_state_t,
}
impl Default for ec_ioctl_link_state_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_slave_dict_upload_t {
    pub slave_position: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_mbox_gateway_t {
    pub data_size: size_t,
    pub buff_size: size_t,
    pub data: *mut u8,
}
impl Default for ec_ioctl_mbox_gateway_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
