/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const EC_MAX_NUM_DEVICES: u32 = 1;
pub const EC_MAX_SYNC_MANAGERS: u32 = 16;
pub const EC_MAX_STRING_LENGTH: u32 = 64;
pub const EC_MAX_PORTS: u32 = 4;
pub const EC_MAX_SII_SIZE: u32 = 4096;
pub const EC_MAX_FMMUS: u32 = 16;
pub const EC_MAX_HOSTNAME_SIZE: u32 = 32;
pub const EC_IOCTL_TYPE: u32 = 164;
pub const EC_IOCTL_VERSION_MAGIC: u32 = 37;
pub const EC_IOCTL_STRING_SIZE: u32 = 64;
pub const EC_MAX_SDO_DATA_SIZE: u32 = 1024;
pub const EC_MAX_IDN_DATA_SIZE: u32 = 1024;
pub const EC_MAX_FLAG_KEY_SIZE: u32 = 128;
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[doc = " Master state.\n\n This is used for the output parameter of ecrt_master_state().\n\n \\see ecrt_master_state()."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_master_state_t {
    #[doc = "< Sum of responding slaves on all\nEthernet devices."]
    pub slaves_responding: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ec_master_state_t {
    #[inline]
    pub fn al_states(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_states(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn link_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        al_states: ::std::os::raw::c_uint,
        link_up: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let al_states: u32 = unsafe { ::std::mem::transmute(al_states) };
            al_states as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let link_up: u32 = unsafe { ::std::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Redundant link state.\n\n This is used for the output parameter of ecrt_master_link_state().\n\n \\see ecrt_master_link_state()."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_master_link_state_t {
    #[doc = "< Sum of responding slaves on the given\nlink."]
    pub slaves_responding: ::std::os::raw::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ec_master_link_state_t {
    #[inline]
    pub fn al_states(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_states(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn link_up(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        al_states: ::std::os::raw::c_uint,
        link_up: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let al_states: u32 = unsafe { ::std::mem::transmute(al_states) };
            al_states as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let link_up: u32 = unsafe { ::std::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Slave configuration state.\n\n This is used as an output parameter of ecrt_slave_config_state().\n\n \\see ecrt_slave_config_state()."]
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct ec_slave_config_state_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ec_slave_config_state_t {
    #[inline]
    pub fn online(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_online(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn operational(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_operational(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn al_state(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_al_state(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        online: ::std::os::raw::c_uint,
        operational: ::std::os::raw::c_uint,
        al_state: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let online: u32 = unsafe { ::std::mem::transmute(online) };
            online as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let operational: u32 = unsafe { ::std::mem::transmute(operational) };
            operational as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let al_state: u32 = unsafe { ::std::mem::transmute(al_state) };
            al_state as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Port is not implemented."]
pub const EC_PORT_NOT_IMPLEMENTED: ec_slave_port_desc_t = 0;
#[doc = "< Port is not configured."]
pub const EC_PORT_NOT_CONFIGURED: ec_slave_port_desc_t = 1;
#[doc = "< Port is an E-Bus."]
pub const EC_PORT_EBUS: ec_slave_port_desc_t = 2;
#[doc = "< Port is a MII."]
pub const EC_PORT_MII: ec_slave_port_desc_t = 3;
#[doc = " EtherCAT slave port descriptor."]
pub type ec_slave_port_desc_t = ::std::os::raw::c_uint;
#[doc = " EtherCAT slave port information."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_slave_port_link_t {
    #[doc = "< Link detected."]
    pub link_up: u8,
    #[doc = "< Loop closed."]
    pub loop_closed: u8,
    #[doc = "< Detected signal on RX port."]
    pub signal_detected: u8,
}
#[doc = "< No registered process data were exchanged."]
pub const EC_WC_ZERO: ec_wc_state_t = 0;
#[doc = "< Some of the registered process data were\nexchanged."]
pub const EC_WC_INCOMPLETE: ec_wc_state_t = 1;
#[doc = "< All registered process data were exchanged."]
pub const EC_WC_COMPLETE: ec_wc_state_t = 2;
#[doc = " Domain working counter interpretation.\n\n This is used in ec_domain_state_t."]
pub type ec_wc_state_t = ::std::os::raw::c_uint;
#[doc = " Domain state.\n\n This is used for the output parameter of ecrt_domain_state()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_domain_state_t {
    #[doc = "< Value of the last working counter."]
    pub working_counter: ::std::os::raw::c_uint,
    #[doc = "< Working counter interpretation."]
    pub wc_state: ec_wc_state_t,
    #[doc = "< Redundant link is in use."]
    pub redundancy_active: ::std::os::raw::c_uint,
}
impl Default for ec_domain_state_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Invalid direction. Do not use this value."]
pub const EC_DIR_INVALID: ec_direction_t = 0;
#[doc = "< Values written by the master."]
pub const EC_DIR_OUTPUT: ec_direction_t = 1;
#[doc = "< Values read by the master."]
pub const EC_DIR_INPUT: ec_direction_t = 2;
#[doc = "< Number of directions. For internal use only."]
pub const EC_DIR_COUNT: ec_direction_t = 3;
#[doc = " Direction type for PDO assignment functions."]
pub type ec_direction_t = ::std::os::raw::c_uint;
#[doc = "< Use the default setting of the sync manager."]
pub const EC_WD_DEFAULT: ec_watchdog_mode_t = 0;
#[doc = "< Enable the watchdog."]
pub const EC_WD_ENABLE: ec_watchdog_mode_t = 1;
#[doc = "< Disable the watchdog."]
pub const EC_WD_DISABLE: ec_watchdog_mode_t = 2;
#[doc = " Watchdog mode for sync manager configuration.\n\n Used to specify, if a sync manager's watchdog is to be enabled."]
pub type ec_watchdog_mode_t = ::std::os::raw::c_uint;
#[doc = "< Not requested."]
pub const EC_REQUEST_UNUSED: ec_request_state_t = 0;
#[doc = "< Request is being processed."]
pub const EC_REQUEST_BUSY: ec_request_state_t = 1;
#[doc = "< Request was processed successfully."]
pub const EC_REQUEST_SUCCESS: ec_request_state_t = 2;
#[doc = "< Request processing failed."]
pub const EC_REQUEST_ERROR: ec_request_state_t = 3;
#[doc = " Request state.\n\n This is used as return type for ecrt_sdo_request_state() and\n ecrt_voe_handler_state()."]
pub type ec_request_state_t = ::std::os::raw::c_uint;
#[doc = "< Init."]
pub const EC_AL_STATE_INIT: ec_al_state_t = 1;
#[doc = "< Pre-operational."]
pub const EC_AL_STATE_PREOP: ec_al_state_t = 2;
#[doc = "< Safe-operational."]
pub const EC_AL_STATE_SAFEOP: ec_al_state_t = 4;
#[doc = "< Operational."]
pub const EC_AL_STATE_OP: ec_al_state_t = 8;
#[doc = " Application-layer state."]
pub type ec_al_state_t = ::std::os::raw::c_uint;
#[doc = " Slave information interface CANopen over EtherCAT details flags."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_sii_coe_details_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl ec_sii_coe_details_t {
    #[inline]
    pub fn enable_sdo(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_sdo(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_sdo_info(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_sdo_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_pdo_assign(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_pdo_assign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_pdo_configuration(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_pdo_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_upload_at_startup(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_upload_at_startup(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_sdo_complete_access(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_sdo_complete_access(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_sdo: u8,
        enable_sdo_info: u8,
        enable_pdo_assign: u8,
        enable_pdo_configuration: u8,
        enable_upload_at_startup: u8,
        enable_sdo_complete_access: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_sdo: u8 = unsafe { ::std::mem::transmute(enable_sdo) };
            enable_sdo as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_sdo_info: u8 = unsafe { ::std::mem::transmute(enable_sdo_info) };
            enable_sdo_info as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let enable_pdo_assign: u8 = unsafe { ::std::mem::transmute(enable_pdo_assign) };
            enable_pdo_assign as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enable_pdo_configuration: u8 =
                unsafe { ::std::mem::transmute(enable_pdo_configuration) };
            enable_pdo_configuration as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enable_upload_at_startup: u8 =
                unsafe { ::std::mem::transmute(enable_upload_at_startup) };
            enable_upload_at_startup as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let enable_sdo_complete_access: u8 =
                unsafe { ::std::mem::transmute(enable_sdo_complete_access) };
            enable_sdo_complete_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Slave information interface general flags."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_sii_general_flags_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl ec_sii_general_flags_t {
    #[inline]
    pub fn enable_safeop(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_safeop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_not_lrw(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_not_lrw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable_safeop: u8,
        enable_not_lrw: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable_safeop: u8 = unsafe { ::std::mem::transmute(enable_safeop) };
            enable_safeop as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_not_lrw: u8 = unsafe { ::std::mem::transmute(enable_not_lrw) };
            enable_not_lrw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< 32 bit."]
pub const EC_DC_32: ec_slave_dc_range_t = 0;
pub const EC_DC_64: ec_slave_dc_range_t = 1;
#[doc = " EtherCAT slave distributed clocks range."]
pub type ec_slave_dc_range_t = ::std::os::raw::c_uint;
#[doc = " EtherCAT slave sync signal configuration."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_sync_signal_t {
    #[doc = "< Cycle time [ns]."]
    pub cycle_time: u32,
    #[doc = "< Shift time [ns]."]
    pub shift_time: i32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_module_t {
    pub ioctl_version_magic: u32,
    pub master_count: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_master_t {
    pub slave_count: u32,
    pub scan_index: u32,
    pub config_count: u32,
    pub domain_count: u32,
    pub eoe_handler_count: u32,
    pub phase: u8,
    pub active: u8,
    pub scan_busy: u8,
    pub devices: [ec_ioctl_master_t_ec_ioctl_device; 1usize],
    pub num_devices: u32,
    pub tx_count: u64,
    pub rx_count: u64,
    pub tx_bytes: u64,
    pub rx_bytes: u64,
    pub tx_frame_rates: [i32; 3usize],
    pub rx_frame_rates: [i32; 3usize],
    pub tx_byte_rates: [i32; 3usize],
    pub rx_byte_rates: [i32; 3usize],
    pub loss_rates: [i32; 3usize],
    pub app_time: u64,
    pub dc_ref_time: u64,
    pub ref_clock: u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_master_t_ec_ioctl_device {
    pub address: [u8; 6usize],
    pub attached: u8,
    pub link_state: u8,
    pub tx_count: u64,
    pub rx_count: u64,
    pub tx_bytes: u64,
    pub rx_bytes: u64,
    pub tx_errors: u64,
    pub tx_frame_rates: [i32; 3usize],
    pub rx_frame_rates: [i32; 3usize],
    pub tx_byte_rates: [i32; 3usize],
    pub rx_byte_rates: [i32; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_t {
    pub position: u16,
    pub device_index: ::std::os::raw::c_uint,
    pub vendor_id: u32,
    pub product_code: u32,
    pub revision_number: u32,
    pub serial_number: u32,
    pub alias: u16,
    pub boot_rx_mailbox_offset: u16,
    pub boot_rx_mailbox_size: u16,
    pub boot_tx_mailbox_offset: u16,
    pub boot_tx_mailbox_size: u16,
    pub std_rx_mailbox_offset: u16,
    pub std_rx_mailbox_size: u16,
    pub std_tx_mailbox_offset: u16,
    pub std_tx_mailbox_size: u16,
    pub mailbox_protocols: u16,
    pub has_general_category: u8,
    pub coe_details: ec_sii_coe_details_t,
    pub general_flags: ec_sii_general_flags_t,
    pub current_on_ebus: i16,
    pub ports: [ec_ioctl_slave_t__bindgen_ty_1; 4usize],
    pub fmmu_bit: u8,
    pub dc_supported: u8,
    pub dc_range: ec_slave_dc_range_t,
    pub has_dc_system_time: u8,
    pub transmission_delay: u32,
    pub al_state: u8,
    pub error_flag: u8,
    pub sync_count: u8,
    pub sdo_count: u16,
    pub sii_nwords: u32,
    pub group: [::std::os::raw::c_char; 64usize],
    pub image: [::std::os::raw::c_char; 64usize],
    pub order: [::std::os::raw::c_char; 64usize],
    pub name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_t__bindgen_ty_1 {
    pub desc: ec_slave_port_desc_t,
    pub link: ec_slave_port_link_t,
    pub receive_time: u32,
    pub next_slave: u16,
    pub delay_to_next_dc: u32,
}
impl Default for ec_ioctl_slave_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ec_ioctl_slave_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_slave_sync_t {
    pub slave_position: u16,
    pub sync_index: u32,
    pub physical_start_address: u16,
    pub default_size: u16,
    pub control_register: u8,
    pub enable: u8,
    pub pdo_count: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sync_pdo_t {
    pub slave_position: u16,
    pub sync_index: u32,
    pub pdo_pos: u32,
    pub index: u16,
    pub entry_count: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sync_pdo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sync_pdo_entry_t {
    pub slave_position: u16,
    pub sync_index: u32,
    pub pdo_pos: u32,
    pub entry_pos: u32,
    pub index: u16,
    pub subindex: u8,
    pub bit_length: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sync_pdo_entry_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_domain_t {
    pub index: u32,
    pub data_size: u32,
    pub logical_base_address: u32,
    pub working_counter: [u16; 1usize],
    pub expected_working_counter: u16,
    pub fmmu_count: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_domain_fmmu_t {
    pub domain_index: u32,
    pub fmmu_index: u32,
    pub slave_config_alias: u16,
    pub slave_config_position: u16,
    pub sync_index: u8,
    pub dir: ec_direction_t,
    pub logical_address: u32,
    pub data_size: u32,
}
impl Default for ec_ioctl_domain_fmmu_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_domain_data_t {
    pub domain_index: u32,
    pub data_size: u32,
    pub target: *mut u8,
}
impl Default for ec_ioctl_domain_data_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_slave_state_t {
    pub slave_position: u16,
    pub al_state: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_t {
    pub slave_position: u16,
    pub sdo_position: u16,
    pub sdo_index: u16,
    pub max_subindex: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sdo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_entry_t {
    pub slave_position: u16,
    pub sdo_spec: ::std::os::raw::c_int,
    pub sdo_entry_subindex: u8,
    pub data_type: u16,
    pub bit_length: u16,
    pub read_access: [u8; 3usize],
    pub write_access: [u8; 3usize],
    pub description: [i8; 64usize],
}
impl Default for ec_ioctl_slave_sdo_entry_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_upload_t {
    pub slave_position: u16,
    pub sdo_index: u16,
    pub sdo_entry_subindex: u8,
    pub target_size: usize,
    pub target: *mut u8,
    pub data_size: usize,
    pub abort_code: u32,
}
impl Default for ec_ioctl_slave_sdo_upload_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sdo_download_t {
    pub slave_position: u16,
    pub sdo_index: u16,
    pub sdo_entry_subindex: u8,
    pub complete_access: u8,
    pub data_size: usize,
    pub data: *mut u8,
    pub abort_code: u32,
}
impl Default for ec_ioctl_slave_sdo_download_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_sii_t {
    pub slave_position: u16,
    pub offset: u16,
    pub nwords: u32,
    pub words: *mut u16,
}
impl Default for ec_ioctl_slave_sii_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_reg_t {
    pub slave_position: u16,
    pub emergency: u8,
    pub address: u16,
    pub size: usize,
    pub data: *mut u8,
}
impl Default for ec_ioctl_slave_reg_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_foe_t {
    pub slave_position: u16,
    pub offset: u16,
    pub buffer_size: usize,
    pub buffer: *mut u8,
    pub data_size: usize,
    pub result: u32,
    pub error_code: u32,
    pub file_name: [::std::os::raw::c_char; 32usize],
}
impl Default for ec_ioctl_slave_foe_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_soe_read_t {
    pub slave_position: u16,
    pub drive_no: u8,
    pub idn: u16,
    pub mem_size: usize,
    pub data: *mut u8,
    pub data_size: usize,
    pub error_code: u16,
}
impl Default for ec_ioctl_slave_soe_read_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_slave_soe_write_t {
    pub slave_position: u16,
    pub drive_no: u8,
    pub idn: u16,
    pub data_size: usize,
    pub data: *mut u8,
    pub error_code: u16,
}
impl Default for ec_ioctl_slave_soe_write_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_t {
    pub config_index: u32,
    pub alias: u16,
    pub position: u16,
    pub vendor_id: u32,
    pub product_code: u32,
    pub syncs: [ec_ioctl_config_t__bindgen_ty_1; 16usize],
    pub watchdog_divider: u16,
    pub watchdog_intervals: u16,
    pub sdo_count: u32,
    pub idn_count: u32,
    pub flag_count: u32,
    pub slave_position: i32,
    pub dc_assign_activate: u16,
    pub dc_sync: [ec_sync_signal_t; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_t__bindgen_ty_1 {
    pub dir: ec_direction_t,
    pub watchdog_mode: ec_watchdog_mode_t,
    pub pdo_count: u32,
    pub config_this: u8,
}
impl Default for ec_ioctl_config_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ec_ioctl_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_pdo_t {
    pub config_index: u32,
    pub sync_index: u8,
    pub pdo_pos: u16,
    pub index: u16,
    pub entry_count: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_config_pdo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_pdo_entry_t {
    pub config_index: u32,
    pub sync_index: u8,
    pub pdo_pos: u16,
    pub entry_pos: u8,
    pub index: u16,
    pub subindex: u8,
    pub bit_length: u8,
    pub name: [i8; 64usize],
}
impl Default for ec_ioctl_config_pdo_entry_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_sdo_t {
    pub config_index: u32,
    pub sdo_pos: u32,
    pub index: u16,
    pub subindex: u8,
    pub size: usize,
    pub data: [u8; 1024usize],
    pub complete_access: u8,
}
impl Default for ec_ioctl_config_sdo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_idn_t {
    pub config_index: u32,
    pub idn_pos: u32,
    pub drive_no: u8,
    pub idn: u16,
    pub state: ec_al_state_t,
    pub size: usize,
    pub data: [u8; 1024usize],
}
impl Default for ec_ioctl_config_idn_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_config_flag_t {
    pub config_index: u32,
    pub flag_pos: u32,
    pub key: [::std::os::raw::c_char; 128usize],
    pub value: i32,
}
impl Default for ec_ioctl_config_flag_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_eoe_handler_t {
    pub eoe_index: u16,
    pub name: [::std::os::raw::c_char; 20usize],
    pub slave_position: u16,
    pub open: u8,
    pub rx_bytes: u32,
    pub rx_rate: u32,
    pub tx_bytes: u32,
    pub tx_rate: u32,
    pub tx_queued_frames: u32,
    pub tx_queue_size: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_eoe_ip_t {
    pub slave_position: u16,
    pub config_index: u16,
    pub mac_address_included: u8,
    pub ip_address_included: u8,
    pub subnet_mask_included: u8,
    pub gateway_included: u8,
    pub dns_included: u8,
    pub name_included: u8,
    pub mac_address: [::std::os::raw::c_uchar; 6usize],
    pub ip_address: in_addr,
    pub subnet_mask: in_addr,
    pub gateway: in_addr,
    pub dns: in_addr,
    pub name: [::std::os::raw::c_char; 32usize],
    pub result: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_master_activate_t {
    pub process_data: *mut ::std::os::raw::c_void,
    pub process_data_size: usize,
}
impl Default for ec_ioctl_master_activate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_add_pdo_entry_t {
    pub config_index: u32,
    pub pdo_index: u16,
    pub entry_index: u16,
    pub entry_subindex: u8,
    pub entry_bit_length: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_reg_pdo_entry_t {
    pub config_index: u32,
    pub entry_index: u16,
    pub entry_subindex: u8,
    pub domain_index: u32,
    pub bit_position: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ec_ioctl_reg_pdo_pos_t {
    pub config_index: u32,
    pub sync_index: u32,
    pub pdo_pos: u32,
    pub entry_pos: u32,
    pub domain_index: u32,
    pub bit_position: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_sdo_t {
    pub config_index: u32,
    pub index: u16,
    pub subindex: u8,
    pub data: *const u8,
    pub size: usize,
    pub complete_access: u8,
}
impl Default for ec_ioctl_sc_sdo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_emerg_t {
    pub config_index: u32,
    pub size: usize,
    pub target: *mut u8,
    pub overruns: i32,
}
impl Default for ec_ioctl_sc_emerg_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_state_t {
    pub config_index: u32,
    pub state: *mut ec_slave_config_state_t,
}
impl Default for ec_ioctl_sc_state_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_idn_t {
    pub config_index: u32,
    pub drive_no: u8,
    pub idn: u16,
    pub al_state: ec_al_state_t,
    pub data: *const u8,
    pub size: usize,
}
impl Default for ec_ioctl_sc_idn_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_flag_t {
    pub config_index: u32,
    pub key_size: usize,
    pub key: *mut ::std::os::raw::c_char,
    pub value: i32,
}
impl Default for ec_ioctl_sc_flag_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sc_state_timeout_t {
    pub config_index: u32,
    pub from_state: ec_al_state_t,
    pub to_state: ec_al_state_t,
    pub timeout_ms: u32,
}
impl Default for ec_ioctl_sc_state_timeout_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_domain_state_t {
    pub domain_index: u32,
    pub state: *mut ec_domain_state_t,
}
impl Default for ec_ioctl_domain_state_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_sdo_request_t {
    pub config_index: u32,
    pub request_index: u32,
    pub sdo_index: u16,
    pub sdo_subindex: u8,
    pub size: usize,
    pub data: *mut u8,
    pub timeout: u32,
    pub state: ec_request_state_t,
}
impl Default for ec_ioctl_sdo_request_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_soe_request_t {
    pub config_index: u32,
    pub request_index: u32,
    pub drive_no: u8,
    pub idn: u16,
    pub size: usize,
    pub data: *mut u8,
    pub timeout: u32,
    pub state: ec_request_state_t,
}
impl Default for ec_ioctl_soe_request_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_reg_request_t {
    pub config_index: u32,
    pub mem_size: usize,
    pub request_index: u32,
    pub data: *mut u8,
    pub state: ec_request_state_t,
    pub new_data: u8,
    pub address: u16,
    pub transfer_size: usize,
}
impl Default for ec_ioctl_reg_request_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_voe_t {
    pub config_index: u32,
    pub voe_index: u32,
    pub vendor_id: *mut u32,
    pub vendor_type: *mut u16,
    pub size: usize,
    pub data: *mut u8,
    pub state: ec_request_state_t,
}
impl Default for ec_ioctl_voe_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ioctl_link_state_t {
    pub dev_idx: u32,
    pub state: *mut ec_master_link_state_t,
}
impl Default for ec_ioctl_link_state_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
